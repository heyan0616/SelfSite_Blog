{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{263:function(t,a,r){t.exports=r.p+\"assets/img/iomodelandthreadmodel-1.f4fe0afe.jpg\"},264:function(t,a,r){t.exports=r.p+\"assets/img/iomodelandthreadmodel-2.c70354ac.jpg\"},265:function(t,a,r){t.exports=r.p+\"assets/img/iomodelandthreadmodel-3.2694f9d4.jpg\"},384:function(t,a,r){\"use strict\";r.r(a);var v=r(0),i=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"高性能网络编程中的io模型与线程模型\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#高性能网络编程中的io模型与线程模型\"}},[t._v(\"#\")]),t._v(\" 高性能网络编程中的IO模型与线程模型\")]),t._v(\" \"),v(\"div\",{staticClass:\"custom-block tip\"},[v(\"p\",{staticClass:\"custom-block-title\"},[t._v(\"此文为转载 （通常一篇文章会参考多处，也会添加自己的理解，引用地址如有遗漏，请指出）\")]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"http://www.52im.net/thread-561-1-1.html\")])])]),t._v(\" \"),v(\"br\"),t._v(\" \"),v(\"h2\",{attrs:{id:\"高性能网络编程中的io模型\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#高性能网络编程中的io模型\"}},[t._v(\"#\")]),t._v(\" 高性能网络编程中的IO模型\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"互联网服务端处理网络请求的原理\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#互联网服务端处理网络请求的原理\"}},[t._v(\"#\")]),t._v(\" 互联网服务端处理网络请求的原理\")]),t._v(\" \"),v(\"br\"),t._v(\" \"),v(\"div\",{staticStyle:{display:\"flex\"}},[v(\"img\",{staticStyle:{zoom:\"35%\",display:\"block\"},attrs:{src:r(263),alt:\"\",align:\"left\"}})]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"由上图可以看到，主要处理步骤包括：\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）；\")]),t._v(\" \"),v(\"li\",[t._v(\"3）返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端（5-7）。\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"设计服务端并发模型时，主要有如下两个关键点：\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）服务器如何管理连接，获取输入数据；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）服务器如何处理请求。\")])]),t._v(\" \"),v(\"p\",[t._v(\"以上两个关键点最终都与操作系统的 I/O 模型以及线程(进程)模型相关，下面先详细介绍这I/O模型。\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"“i-o-模型”的基本认识\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#“i-o-模型”的基本认识\"}},[t._v(\"#\")]),t._v(\" “I/O 模型”的基本认识\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"介绍操作系统的 I/O 模型之前，先了解一下几个概念：\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）阻塞调用与非阻塞调用；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；\")]),t._v(\" \"),v(\"li\",[t._v(\"3）非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\")])]),t._v(\" \"),v(\"p\",[t._v(\"两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。\")]),t._v(\" \"),v(\"p\",[v(\"font\",{attrs:{color:\"#af693e\"}},[v(\"strong\",[t._v(\"阻塞\")]),t._v(\"是指调用方一直在等待而且别的事情什么都不做；\"),v(\"strong\",[t._v(\"非阻塞\")]),t._v(\"是指调用方先去忙别的事情。\")])],1),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"同步处理与异步处理\")]),t._v(\":同步处理是指被调用方得到最终结果之后才返回给调用方；异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"阻塞、非阻塞和同步、异步的区别（阻塞、非阻塞和同步、异步其实针对的对象是不一样的）\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）阻塞、非阻塞的讨论对象是调用者；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）同步、异步的讨论对象是被调用者。\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"recvfrom 函数：\")])]),t._v(\" \"),v(\"p\",[t._v(\"recvfrom 函数(经 Socket 接收数据)，这里把它视为系统调用。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"一个IO输入操作通常包括两个不同的阶段：\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）等待数据准备好；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）从内核向进程复制数据。\")])]),t._v(\" \"),v(\"p\",[t._v(\"对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\"),v(\"br\"),t._v(\"实际应用程序在系统调用完成上面的 2 步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时，处理方式的同步、异步处理的不同，可以分为 5 种 I/O 模型（下面的章节将逐个展开介绍）。（参考《\"),v(\"a\",{attrs:{href:\"http://www.52im.net/thread-1015-1-1.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"UNIX网络编程卷1\"),v(\"OutboundLink\")],1),t._v(\"》）\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"i-o模型1：阻塞式-i-o-模型-blocking-i-o）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#i-o模型1：阻塞式-i-o-模型-blocking-i-o）\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"I/O模型1：阻塞式 I/O 模型(blocking I/O）\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"i-o模型2：非阻塞式-i-o-模型-non-blocking-i-o）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#i-o模型2：非阻塞式-i-o-模型-non-blocking-i-o）\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"I/O模型2：非阻塞式 I/O 模型(non-blocking I/O）\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"i-o模型3：i-o-复用模型-i-o-multiplexing）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#i-o模型3：i-o-复用模型-i-o-multiplexing）\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"I/O模型3：I/O 复用模型(I/O multiplexing）\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"i-o模型4：信号驱动式-i-o-模型-signal-driven-i-o\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#i-o模型4：信号驱动式-i-o-模型-signal-driven-i-o\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"I/O模型4：信号驱动式 I/O 模型(signal-driven I/O)\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"i-o模型5：异步-i-o-模型-即aio，全称asynchronous-i-o）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#i-o模型5：异步-i-o-模型-即aio，全称asynchronous-i-o）\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"I/O模型5：异步 I/O 模型(即AIO，全称asynchronous I/O）\")])]),t._v(\" \"),v(\"p\",[t._v(\"亦可参考 “\"),v(\"a\",{attrs:{href:\"https://heyan.site:8001/Java/JavaNIO/IOTheory.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"IO - 同步，异步，阻塞，非阻塞\"),v(\"OutboundLink\")],1),t._v(\"”；\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"_5-种-i-o-模型总结\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-种-i-o-模型总结\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"5 种 I/O 模型总结\")])]),t._v(\" \"),v(\"br\"),t._v(\" \"),v(\"div\",{staticStyle:{display:\"flex\"}},[v(\"img\",{staticStyle:{zoom:\"30%\",display:\"block\"},attrs:{src:r(264),alt:\"\",align:\"left\"}})]),t._v(\" \"),v(\"p\",[t._v(\"从上图中我们可以看出，越往后，阻塞越少，理论上效率也是最优。\"),v(\"br\"),t._v(\"这五种 I/O 模型中，前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。\")]),t._v(\" \"),v(\"h2\",{attrs:{id:\"高性能网络编程中的线程模型\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#高性能网络编程中的线程模型\"}},[t._v(\"#\")]),t._v(\" 高性能网络编程中的线程模型\")]),t._v(\" \"),v(\"p\",[t._v(\"上面介绍完服务器如何基于 I/O 模型管理连接，获取输入数据，下面将介绍基于进程/线程模型，服务器如何处理请求。\"),v(\"br\"),t._v(\"值得说明的是，具体选择线程还是进程，更多是与平台及编程语言相关。\"),v(\"br\"),t._v(\"例如 C 语言使用线程和进程都可以(例如 Nginx 使用进程，Memcached 使用线程)，Java 语言一般使用线程(例如 Netty)，为了描述方便，下面都使用线程来进行描述。\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"线程模型1：传统阻塞-i-o-服务模型\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程模型1：传统阻塞-i-o-服务模型\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"线程模型1：传统阻塞 I/O 服务模型\")])]),t._v(\" \"),v(\"br\"),t._v(\" \"),v(\"div\",{staticStyle:{display:\"flex\"}},[v(\"img\",{staticStyle:{zoom:\"35%\",display:\"block\"},attrs:{src:r(265),alt:\"\",align:\"left\"}})]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"特点：\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）采用阻塞式 I/O 模型获取输入数据；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作。\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"存在问题：\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"线程模型2：reactor-模式\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程模型2：reactor-模式\"}},[t._v(\"#\")]),t._v(\" \"),v(\"strong\",[t._v(\"线程模型2：Reactor 模式\")])]),t._v(\" \"),v(\"h4\",{attrs:{id:\"_1-基本介绍\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-基本介绍\"}},[t._v(\"#\")]),t._v(\" 1 基本介绍\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"针对传统阻塞 I/O 服务模型的 2 个缺点，比较常见的有如下解决方案：\")])]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1）基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；\")]),t._v(\" \"),v(\"li\",[t._v(\"2）基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"I/O 复用结合线程池，这就是 Reactor 模式基本设计思想，如下图：\")])])])}),[],!1,null,null,null);a.default=i.exports}}]);","extractedComments":[]}